using System.Diagnostics.CodeAnalysis;
using System.Numerics;
using Uuid;

namespace FoodTech.Uuid.Final;

using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Security.Cryptography;
using Uuid;

#if NET7_0_OR_GREATER
using System.Runtime.Intrinsics;
#endif

/// <summary>
/// UUIDv7 is modern time-based UUID version.
/// <para>It offers a precise timestamp, up to 50 nanosecond resolution.</para>
/// <para>As primary key it works much better compare to native .NET Guid(UUID4).</para>
/// Implements UUID version 7 as defined in RFC draft at
/// https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-03.html.
/// <remarks>Code forked from https://github.com/medo64/Medo.Uuid7/blob/main/src/Medo.Uuid7/Uuid7.cs</remarks>
/// </summary>
[DebuggerDisplay("{ToString(),nq}")]
[StructLayout(LayoutKind.Sequential)]
public readonly struct Uuid7 :
    IFormattable,
    IComparable,
    IComparable<Uuid7>,
    IEquatable<Uuid7>,
    IComparable<Guid>,
    IEquatable<Guid>
{
    private const long UnixEpochMilliseconds = 62_135_596_800_000;
    private const long TicksPerMillisecond = 10_000;

    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
    private readonly byte[] Bytes;

    private static readonly RandomNumberGenerator Random = RandomNumberGenerator.Create(); // needed due to .NET Standard 2.0
    private const int RandomBufferSize = 2048;
    private static readonly ThreadLocal<byte[]> RandomBuffer = new(() => new byte[RandomBufferSize]);
    private static readonly ThreadLocal<int> RandomBufferIndex = new(() => RandomBufferSize); // first call needs to fill buffer no matter what

    private static readonly object NonThreadedSyncRoot = new();
    private static long NonThreadedLastMillisecond; // real time in milliseconds since 0001-01-01
    private static long NonThreadedMillisecondCounter; // usually real time but doesn't go backward
    private static uint NonThreadedMonotonicCounter; // counter that gets embedded into UUID

    [ThreadStatic]
    private static long PerThreadLastMillisecond; // real time in milliseconds since 0001-01-01

    [ThreadStatic]
    private static long PerThreadMillisecondCounter; // usually real time but doesn't go backward

    [ThreadStatic]
    private static uint PerThreadMonotonicCounter; // counter that gets embedded into UUID

    /// <summary>
    /// Creates a new version 7 UUID.
    /// Sequencing is done on a per-thread basis. This means that each thread
    /// maintains a separate counter, and thus sequences generated by different
    /// threads might overlap. Please note that this overlap is no  worse than
    /// what one would expect if the code was executing on a different computer.
    /// However, if strict sequencing is required, please use the static
    /// NewUuid7() method that guarantees this behavior.
    /// </summary>
    public Uuid7()
    {
        Bytes = new byte[16];
        FillBytes7(Bytes, ref PerThreadLastMillisecond, ref PerThreadMillisecondCounter, ref PerThreadMonotonicCounter);
    }

    /// <summary>
    /// Creates a new instance from given GUID bytes.
    /// No check if GUID is version 7 UUID is made.
    /// Base endianness is littleEndian between convert
    /// </summary>
    public Uuid7(Guid guid)
    {
        Bytes = guid.ToByteArray(true);
    }

    public Uuid7(ReadOnlySpan<byte> span)
    {
        ArgumentNullException.ThrowIfNull(nameof(span));
        if (span.Length != 16) ArgumentOutOfRangeException.ThrowIfNotEqual(16, span.Length, nameof(span));

        Bytes = new byte[16];
        span.CopyTo(Bytes);
    }

    public Uuid7(string input)
    {
        ArgumentNullException.ThrowIfNull(input);

        var result = new UuidResult();
        TryParseUuid(input, ref result);
        Bytes = result.Bytes;
    }
    
    /// <summary>
    /// Creates a new instance with a given byte array with no validation
    /// </summary>
    private Uuid7(Span<byte> buffer)
    {
        Bytes = buffer.ToArray();
    }

    /// <summary>
    /// A read-only instance of the Uuid7 - all values are zeros.
    /// Please note this is not a valid UUID7 as it lacks the correct version bits.
    /// </summary>
    public static readonly Uuid7 Empty = new(new byte[16]);

    /// <summary>
    /// A read-only instance of the Uuid7 - all values are zeros.
    /// Please note this is not a valid UUID7 as it lacks the correct version bits.
    /// </summary>
    public static readonly Uuid7 MinValue = new(new byte[16]);

    /// <summary>
    /// A read-only instance of the Uuid7 - all values are FF.
    /// Please note this is not a valid UUID7 as it lacks the correct version bits.
    /// </summary>
    public static readonly Uuid7 MaxValue = new(new byte[] { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 });

    /// <summary>
    /// Returns a new UUID version 7.
    /// This method is thread-safe.
    /// For higher multi-threaded performance, consider using new Uuid7()
    /// instead, as it utilizes per-thread counters. While this doesn't
    /// guarantee strict sequencing, it provides no worse results than
    /// generating UUIDs on multiple computers.
    /// </summary>
    public static Uuid7 NewUuid7() {
        Span<byte> bytes = stackalloc byte[16];
        lock (NonThreadedSyncRoot) {
            FillBytes7(bytes, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);
        }
        return new Uuid7(bytes);
    }

    public static Uuid7 FromGuid(Guid value) => new Uuid7(value.ToByteArray(true));
    public Guid ToGuid() => new Guid(Bytes, true);
    public static Guid ToGuid(Uuid7 uuid7MemorySpan) => new Guid(uuid7MemorySpan.Bytes, true);

    public byte[] ToByteArray()
    {
        Span<byte> copy = stackalloc byte[16];
        Bytes.CopyTo(copy);
        return copy.ToArray();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    private static void FillBytes7(Span<byte> bytes, ref long lastMillisecond, ref long millisecondCounter, ref uint monotonicCounter)
    {
        var ticks = DateTime.UtcNow.Ticks; // DateTime is a smidgen faster than DateTimeOffset
        var millisecond = ticks / TicksPerMillisecond;
        var msCounter = millisecondCounter;

        var newStep = millisecond != lastMillisecond;
        if (newStep) {  // we need to switch millisecond (i.e. counter)
            lastMillisecond = millisecond;
            var ms = unchecked(millisecond - UnixEpochMilliseconds);
            if (msCounter < ms) {  // normal time progression
                msCounter = ms;
            } else { // time went backward, just increase counter
                unchecked { msCounter++; }
            }

            millisecondCounter = msCounter;
        }

        // Timestamp
        bytes[0] = (byte)(msCounter >> 40);
        bytes[1] = (byte)(msCounter >> 32);
        bytes[2] = (byte)(msCounter >> 24);
        bytes[3] = (byte)(msCounter >> 16);
        bytes[4] = (byte)(msCounter >> 8);
        bytes[5] = (byte)msCounter;

        // Randomness
        uint monoCounter;
        if (newStep) {
            GetRandomBytes(bytes, 6, 10);
            // to use as monotonic random for future calls; total of 26 bits but only 25 are used initially with upper 1 bit reserved for rollover guard
            monoCounter = (uint)(((bytes[6] & 0x07) << 22) | (bytes[7] << 14) | ((bytes[8] & 0x3F) << 8) | bytes[9]);
        } else {
            GetRandomBytes(bytes, 9, 7);
            // 4 bit random increment will reduce overall counter space by 3 bits on average (to 2^22 combinations)
            monoCounter = unchecked(monotonicCounter + ((uint)bytes[9] >> 4) + 1);
            bytes[7] = (byte)(monoCounter >> 14); // bits 14:21 of monotonic counter
            bytes[9] = (byte)(monoCounter); // bits 0:7 of monotonic counter
        }

        monotonicCounter = monoCounter;

        //Fixup
        bytes[6] = (byte)(0x70 | ((monoCounter >> 22) & 0x0F)); // set 4-bit version + bits 22:25 of monotonic counter
        bytes[8] = (byte)(0x80 | ((monoCounter >> 8) & 0x3F)); // set 2-bit variant + bits 8:13 of monotonic counter
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    private static void GetRandomBytes(Span<byte> bytes, int offset, int count)
    {
        var buffer = RandomBuffer.Value!.AsSpan();
        var bufferIndex = RandomBufferIndex.Value;

        if (unchecked(bufferIndex + count) > RandomBufferSize) {
            var leftover = unchecked(RandomBufferSize - bufferIndex);
            buffer.Slice(bufferIndex).CopyTo(bytes.Slice(offset, count)); // make sure to use all bytes

            offset = unchecked(offset + leftover);
            count = unchecked(count - leftover);

            Random.GetBytes(buffer);
            bufferIndex = 0;
        }

        buffer.Slice(bufferIndex, count).CopyTo(bytes.Slice(offset, count));
        RandomBufferIndex.Value = unchecked(bufferIndex + count);
    }

    #region IEquatable

    public override bool Equals(object? o)
    {
        if (o is Uuid7 uuid7) return Equals(uuid7);
        if (o is Guid guid) return Equals(guid);

        return false;
    }

    public override int GetHashCode()
    {
        return ((Bytes[3] ^ Bytes[7] ^ Bytes[11] ^ Bytes[15]) << 24)
            | ((Bytes[2] ^ Bytes[6] ^ Bytes[10] ^ Bytes[14]) << 16)
            | ((Bytes[1] ^ Bytes[5] ^ Bytes[9] ^ Bytes[13]) << 8)
            | (Bytes[0] ^ Bytes[4] ^ Bytes[8] ^ Bytes[12]);
    }

    public bool Equals(Uuid7 other)
    {
#if NET7_0_OR_GREATER
        if (Vector128.IsHardwareAccelerated)
        {
            var vector1 = Unsafe.ReadUnaligned<Vector128<byte>>(ref Bytes[0]);
            var vector2 = Unsafe.ReadUnaligned<Vector128<byte>>(ref other.ToByteArray()[0]);
            return vector1 == vector2;
        }
#endif
        return AreArraysEquals(Bytes, other.Bytes);
    }

    public bool Equals(Guid other)
    {
#if NET7_0_OR_GREATER
        if (Vector128.IsHardwareAccelerated)
        {
            var vector1 = Unsafe.ReadUnaligned<Vector128<byte>>(ref Bytes[0]);
            var vector2 = Unsafe.ReadUnaligned<Vector128<byte>>(ref other.ToByteArray(true)[0]);
            return vector1 == vector2;
        }
#endif
        return AreArraysEquals(Bytes, other.ToByteArray(true));
    }

    private static bool AreArraysEquals(ReadOnlySpan<byte> byteSpan1, ReadOnlySpan<byte> byteSpan2)
    {
        return byteSpan1.SequenceEqual(byteSpan2);
    }

    #endregion

    #region IComparable

    public int CompareTo(Uuid7 other)
    {
        return CompareArrays(Bytes, other.Bytes);
    }

    public int CompareTo(Guid other)
    {
        return CompareArrays(Bytes, other.ToByteArray(true));
    }

    public int CompareTo(object? obj)
    {
        if (obj == null) return 1;
        if (obj is Uuid7 uuid7) return CompareTo(uuid7);
        if (obj is Guid guid) return CompareTo(guid);

        return ThrowIfNotEqual($"Neither {nameof(Guid)} nor {nameof(Uuid7)} but {obj.GetType().Name}");
    }

    private static int CompareArrays(ReadOnlySpan<byte> array1, ReadOnlySpan<byte> array2)
    {
        if (array1 == null || array1.Length != 16) return -1;
        if (array2 == null || array2.Length != 16) return +1;

        var comparer = Comparer<byte>.Default;
        for (var i = 0; i < array1.Length; i++)
        {
            switch (comparer.Compare(array1[i], array2[i]))
            {
                case < 0:
                    return -1;
                case > 0:
                    return +1;
            }
        }

        return 0;
    }

    #endregion

    #region Operators

    public static bool operator ==(Uuid7 left, Uuid7 right) => left.Equals(right);
    public static bool operator ==(Uuid7 left, Guid right) => left.Equals(right);
    public static bool operator ==(Guid left, Uuid7 right) => left.Equals(right);
    public static bool operator !=(Uuid7 left, Uuid7 right) => !(left == right);
    public static bool operator !=(Uuid7 left, Guid right) => !(left == right);
    public static bool operator !=(Guid left, Uuid7 right) => !(left == right);
    public static bool operator <(Uuid7 left, Uuid7 right) => left.CompareTo(right) < 0;
    public static bool operator <(Uuid7 left, Guid right) => left.CompareTo(right) < 0;
    public static bool operator <(Guid left, Uuid7 right) => left.CompareTo(right) < 0;
    public static bool operator <=(Uuid7 left, Uuid7 right) => left.CompareTo(right) is < 0 or 0;
    public static bool operator <=(Uuid7 left, Guid right) => left.CompareTo(right) is < 0 or 0;
    public static bool operator <=(Guid left, Uuid7 right) => left.CompareTo(right) is < 0 or 0;

    public static bool operator >=(Uuid7 left, Uuid7 right) => left.CompareTo(right) is > 0 or 0;
    public static bool operator >=(Uuid7 left, Guid right) => left.CompareTo(right) is > 0 or 0;

    public static bool operator >=(Guid left, Uuid7 right) => left.CompareTo(right) is > 0 or 0;
    public static bool operator >(Uuid7 left, Uuid7 right) => left.CompareTo(right) > 0;

    public static bool operator >(Uuid7 left, Guid right) => left.CompareTo(right) > 0;
    public static bool operator >(Guid left, Uuid7 right) => left.CompareTo(right) > 0;

    public static implicit operator Uuid7(Guid value) => FromGuid(value);
    public static implicit operator Guid(Uuid7 value) => ToGuid(value);

    #endregion Operators

    #region ToString

    public override string ToString()
    {
        return ToString("D", provider: null);
    }

    /// <summary>
    /// Formats the value of the current instance using the specified format.
    /// The following format specifiers are supported:
    /// - D: Default - 32 digits separated by hyphens, e.g. 00000000-0000-0000-0000-000000000000
    /// </summary>
    /// <param name="format">The format to use.</param>
    /// <param name="provider">Ignored.</param>
    /// <exception cref="FormatException"></exception>
    public string ToString(string? format, IFormatProvider? provider)
    {
        if (string.IsNullOrEmpty(format)) format = "D";
        if (format.Length != 1) ThrowBadGuidFormatSpecification();
        return format[0] switch
        {
            'D' or 'd' => WriteAsDefaultString(Bytes),
            _ => ThrowBadGuidFormatSpecification()
        };
    }

    private static string WriteAsDefaultString(ReadOnlySpan<byte> bytes)
    {
        Span<char> destChars = stackalloc char[36];

        HexByteToTwoChars(destChars, 0, 1, bytes[0]);
        HexByteToTwoChars(destChars, 2, 3, bytes[1]);
        HexByteToTwoChars(destChars, 4, 5, bytes[2]);
        HexByteToTwoChars(destChars, 6, 7, bytes[3]);
        destChars[8] = '-';
        HexByteToTwoChars(destChars, 9, 10, bytes[4]);
        HexByteToTwoChars(destChars, 11, 12, bytes[5]);
        destChars[13] = '-';
        HexByteToTwoChars(destChars, 14, 15, bytes[6]);
        HexByteToTwoChars(destChars, 16, 17, bytes[7]);
        destChars[18] = '-';
        HexByteToTwoChars(destChars, 19, 20, bytes[8]);
        HexByteToTwoChars(destChars, 21, 22, bytes[9]);
        destChars[23] = '-';
        HexByteToTwoChars(destChars, 24, 25, bytes[10]);
        HexByteToTwoChars(destChars, 26, 27, bytes[11]);
        HexByteToTwoChars(destChars, 28, 29, bytes[12]);
        HexByteToTwoChars(destChars, 30, 31, bytes[13]);
        HexByteToTwoChars(destChars, 32, 33, bytes[14]);
        HexByteToTwoChars(destChars, 34, 35, bytes[15]);

        return new string(destChars);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static void HexByteToTwoChars(Span<char> destChars, byte indexOne, byte indexTwo, byte thisByte)
    {
        destChars[indexOne] = HexConverter.Base16Alphabet[thisByte >> 4];
        destChars[indexTwo] = HexConverter.Base16Alphabet[thisByte & 0x0F];
    }

    #endregion

    #region ParseString

        public static Uuid7 Parse(string input)
    {
        ArgumentNullException.ThrowIfNull(input);
        return Parse((ReadOnlySpan<char>)input);
    }

    public static Uuid7 Parse(ReadOnlySpan<char> input)
    {
        var result = new UuidResult();
        bool success = TryParseUuid(input, ref result);
        return new Uuid7(result.Bytes);
    }

    public static bool TryParse(string input, out Uuid7 result)
    {
        if (string.IsNullOrEmpty(input))
        {
            result = default;
            return false;
        }

        return TryParse((ReadOnlySpan<char>)input, out result);
    }

    public static bool TryParse(ReadOnlySpan<char> input, out Uuid7 result)
    {
        var parseResult = new UuidResult();
        if (TryParseUuid(input, ref parseResult))
        {
            result = new Uuid7(parseResult.Bytes);
            return true;
        }

        result = default;
        return false;
    }

    private static bool TryParseUuid(ReadOnlySpan<char> uuidString, ref UuidResult result)
    {
        uuidString = uuidString.Trim();

        if (uuidString.Length < 32) return false;
        return uuidString[0] switch
        {
            '(' => TryParseExactP(uuidString, ref result),
            '{' => uuidString[9] == '-' ?
                TryParseExactB(uuidString, ref result) :
                TryParseExactX(uuidString, ref result),
            _ => uuidString[8] == '-' ?
                TryParseExactD(uuidString, ref result) :
                TryParseExactN(uuidString, ref result),
        };
    }

    private static bool TryParseExactB(ReadOnlySpan<char> guidString, ref UuidResult result)
    {
        // e.g. "{d85b1407-351d-4694-9392-03acc5870eb1}"

        if (guidString.Length != 38 || guidString[0] != '{' || guidString[37] != '}')
        {
            result.SetFailure(ParseFailure.Format_UuidInvLen);
            return false;
        }

        return TryParseExactD(guidString.Slice(1, 36), ref result);
    }

    private static bool TryParseExactD(ReadOnlySpan<char> guidString, ref UuidResult result)
    {
        // e.g. "d85b1407-351d-4694-9392-03acc5870eb1"

        if (guidString.Length != 36 || guidString[8] != '-' || guidString[13] != '-' || guidString[18] != '-' || guidString[23] != '-')
        {
            result.SetFailure(guidString.Length != 36 ? ParseFailure.Format_UuidInvLen : ParseFailure.Format_UuidDashes);
            return false;
        }

        //Span<byte> bytes = stackalloc byte[16];
        Span<byte> bytes = result.Bytes;
        int invalidIfNegative = 0;
        bytes[0] = DecodeByte(guidString[0], guidString[1], ref invalidIfNegative);
        bytes[1] = DecodeByte(guidString[2], guidString[3], ref invalidIfNegative);
        bytes[2] = DecodeByte(guidString[4], guidString[5], ref invalidIfNegative);
        bytes[3] = DecodeByte(guidString[6], guidString[7], ref invalidIfNegative);
        bytes[4] = DecodeByte(guidString[9], guidString[10], ref invalidIfNegative);
        bytes[5] = DecodeByte(guidString[11], guidString[12], ref invalidIfNegative);
        bytes[6] = DecodeByte(guidString[14], guidString[15], ref invalidIfNegative);
        bytes[7] = DecodeByte(guidString[16], guidString[17], ref invalidIfNegative);
        bytes[8] = DecodeByte(guidString[19], guidString[20], ref invalidIfNegative);
        bytes[9] = DecodeByte(guidString[21], guidString[22], ref invalidIfNegative);
        bytes[10] = DecodeByte(guidString[24], guidString[25], ref invalidIfNegative);
        bytes[11] = DecodeByte(guidString[26], guidString[27], ref invalidIfNegative);
        bytes[12] = DecodeByte(guidString[28], guidString[29], ref invalidIfNegative);
        bytes[13] = DecodeByte(guidString[30], guidString[31], ref invalidIfNegative);
        bytes[14] = DecodeByte(guidString[32], guidString[33], ref invalidIfNegative);
        bytes[15] = DecodeByte(guidString[34], guidString[35], ref invalidIfNegative);

        if (invalidIfNegative >= 0)
        {
            return true;
        }

        result.SetFailure(ParseFailure.Format_UuidInvalidChar);
        return false;
    }

    private static bool TryParseExactN(ReadOnlySpan<char> guidString, ref UuidResult result)
    {
        // e.g. "d85b1407351d4694939203acc5870eb1"

        if (guidString.Length != 32)
        {
            result.SetFailure(ParseFailure.Format_UuidInvLen);
            return false;
        }

        //Span<byte> bytes = MemoryMarshal.AsBytes(new Span<UuidResult>(ref result));
        Span<byte> bytes = stackalloc byte[10];
        int invalidIfNegative = 0;
        bytes[0] = DecodeByte(guidString[0], guidString[1], ref invalidIfNegative);
        bytes[1] = DecodeByte(guidString[2], guidString[3], ref invalidIfNegative);
        bytes[2] = DecodeByte(guidString[4], guidString[5], ref invalidIfNegative);
        bytes[3] = DecodeByte(guidString[6], guidString[7], ref invalidIfNegative);
        bytes[4] = DecodeByte(guidString[8], guidString[9], ref invalidIfNegative);
        bytes[5] = DecodeByte(guidString[10], guidString[11], ref invalidIfNegative);
        bytes[6] = DecodeByte(guidString[12], guidString[13], ref invalidIfNegative);
        bytes[7] = DecodeByte(guidString[14], guidString[15], ref invalidIfNegative);
        bytes[8] = DecodeByte(guidString[16], guidString[17], ref invalidIfNegative);
        bytes[9] = DecodeByte(guidString[18], guidString[19], ref invalidIfNegative);
        bytes[10] = DecodeByte(guidString[20], guidString[21], ref invalidIfNegative);
        bytes[11] = DecodeByte(guidString[22], guidString[23], ref invalidIfNegative);
        bytes[12] = DecodeByte(guidString[24], guidString[25], ref invalidIfNegative);
        bytes[13] = DecodeByte(guidString[26], guidString[27], ref invalidIfNegative);
        bytes[14] = DecodeByte(guidString[28], guidString[29], ref invalidIfNegative);
        bytes[15] = DecodeByte(guidString[30], guidString[31], ref invalidIfNegative);

        result.Bytes = bytes.ToArray();

        result.SetFailure(ParseFailure.Format_UuidInvalidChar);
        return false;
    }

    private static bool TryParseExactP(ReadOnlySpan<char> guidString, ref UuidResult result)
    {
        // e.g. "(d85b1407-351d-4694-9392-03acc5870eb1)"

        if (guidString.Length != 38 || guidString[0] != '(' || guidString[37] != ')')
        {
            result.SetFailure(ParseFailure.Format_UuidInvLen);
            return false;
        }

        return TryParseExactD(guidString.Slice(1, 36), ref result);
    }

    private static bool TryParseExactX(ReadOnlySpan<char> guidString, ref UuidResult result)
    {
        result.SetFailure(ParseFailure.Unsupported_UuidFormat);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static byte DecodeByte(char ch1, char ch2, ref int invalidIfNegative)
    {
        ReadOnlySpan<byte> lookup = HexConverter.CharToHexLookup;

        int upper = (sbyte)lookup[(byte)ch1];
        int lower = (sbyte)lookup[(byte)ch2];
        int result = (upper << 4) | lower;

        // Result will be negative if ch1 or/and ch2 are greater than 0xFF
        result = (ch1 | ch2) >> 8 == 0 ? result : -1;
        invalidIfNegative |= result;
        return (byte)result;
    }

    #endregion


    private enum ParseFailure
    {
        Format_ExtraJunkAtEnd,
        Format_UuidBraceAfterLastNumber,
        Format_UuidBrace,
        Format_UuidComma,
        Format_UuidDashes,
        Format_UuidEndBrace,
        Format_UuidHexPrefix,
        Format_UuidInvalidChar,
        Format_UuidInvLen,
        Format_UuidUnrecognized,
        Unsupported_UuidFormat,
        Overflow_Byte,
        Overflow_UInt32,
    }

    private struct UuidResult()
    {
        internal byte[] Bytes = new byte[16];

        internal readonly void SetFailure(ParseFailure failureKind)
        {

            if (failureKind == ParseFailure.Overflow_UInt32)
            {
                throw new OverflowException("Overflow_UInt32");
            }

            if (failureKind == ParseFailure.Unsupported_UuidFormat)
            {
                throw new ArgumentException(nameof(ParseFailure.Unsupported_UuidFormat));
            }

            throw new FormatException(failureKind switch
            {
                ParseFailure.Format_ExtraJunkAtEnd => "Format_ExtraJunkAtEnd",
                ParseFailure.Format_UuidBraceAfterLastNumber => "Format_GuidBraceAfterLastNumber",
                ParseFailure.Format_UuidBrace => "Format_GuidBrace",
                ParseFailure.Format_UuidComma => "Format_GuidComma",
                ParseFailure.Format_UuidDashes => "Format_GuidDashes",
                ParseFailure.Format_UuidEndBrace=> "Format_GuidEndBrace",
                ParseFailure.Format_UuidHexPrefix => "Format_GuidHexPrefix",
                ParseFailure.Format_UuidInvalidChar => "Format_GuidInvalidChar",
                ParseFailure.Format_UuidInvLen => "Format_GuidInvLen",
                _ => "Format_GuidUnrecognized"
            });
        }
    }

    [DoesNotReturn]
    private static string ThrowBadGuidFormatSpecification() => throw new FormatException("Format_InvalidGuidFormatSpecification");

    [DoesNotReturn]
    private static int ThrowIfNotEqual(string message) => throw new ArgumentException(message);
}