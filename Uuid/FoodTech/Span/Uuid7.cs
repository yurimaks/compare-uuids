using Uuid;

namespace FoodTech.Span;

using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Security.Cryptography;
using Uuid;

#if NET7_0_OR_GREATER
using System.Runtime.Intrinsics;
#endif

/// <summary>
/// UUIDv7 is modern time-based UUID version.
/// <para>It offers a precise timestamp, up to 50 nanosecond resolution.</para>
/// <para>As primary key it works much better compare to native .NET Guid(UUID4).</para>
/// Implements UUID version 7 as defined in RFC draft at
/// https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-03.html.
/// <remarks>Code forked from https://github.com/medo64/Medo.Uuid7/blob/main/src/Medo.Uuid7/Uuid7.cs</remarks>
/// </summary>
[DebuggerDisplay("{ToString(),nq}")]
[StructLayout(LayoutKind.Sequential)]
public readonly struct Uuid7 :
    IFormattable,
    IComparable,
    IComparable<Uuid7>,
    IEquatable<Uuid7>,
    IComparable<Guid>,
    IEquatable<Guid>
{
    private const long UnixEpochMilliseconds = 62_135_596_800_000;
    private const long TicksPerMillisecond = 10_000;

    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
    private readonly byte[] Bytes;

    private static readonly RandomNumberGenerator Random = RandomNumberGenerator.Create(); // needed due to .NET Standard 2.0
    private const int RandomBufferSize = 2048;
    private static readonly ThreadLocal<byte[]> RandomBuffer = new(() => new byte[RandomBufferSize]);
    private static readonly ThreadLocal<int> RandomBufferIndex = new(() => RandomBufferSize); // first call needs to fill buffer no matter what

    private static readonly object NonThreadedSyncRoot = new();
    private static long NonThreadedLastMillisecond; // real time in milliseconds since 0001-01-01
    private static long NonThreadedMillisecondCounter; // usually real time but doesn't go backward
    private static uint NonThreadedMonotonicCounter; // counter that gets embedded into UUID

    [ThreadStatic]
    private static long PerThreadLastMillisecond; // real time in milliseconds since 0001-01-01

    [ThreadStatic]
    private static long PerThreadMillisecondCounter; // usually real time but doesn't go backward

    [ThreadStatic]
    private static uint PerThreadMonotonicCounter; // counter that gets embedded into UUID

    /// <summary>
    /// Creates a new version 7 UUID.
    /// Sequencing is done on a per-thread basis. This means that each thread
    /// maintains a separate counter, and thus sequences generated by different
    /// threads might overlap. Please note that this overlap is no  worse than
    /// what one would expect if the code was executing on a different computer.
    /// However, if strict sequencing is required, please use the static
    /// NewUuid7() method that guarantees this behavior.
    /// </summary>
    public Uuid7()
    {
        Bytes = new byte[16];
        FillBytes7(Bytes, ref PerThreadLastMillisecond, ref PerThreadMillisecondCounter, ref PerThreadMonotonicCounter);
    }

    /// <summary>
    /// Creates a new instance from given GUID bytes.
    /// No check if GUID is version 7 UUID is made.
    /// Base endianness is littleEndian between convert
    /// </summary>
    public Uuid7(Guid guid)
    {
        Bytes = guid.ToByteArray(true);
    }
    
    public Uuid7(ReadOnlySpan<byte> span)
    {
        if (span == null) ThrowHelper.ThrowCannotBeNull();
        if (span.Length != 16) ThrowHelper.ThrowOutOfRange16Bytes();

        Bytes = new byte[16];
        span.CopyTo(Bytes);
    }

    /// <summary>
    /// Creates a new instance with a given byte array with no validation
    /// </summary>
    private Uuid7(Span<byte> buffer)
    {
        Bytes = buffer.ToArray();
    }

    /// <summary>
    /// A read-only instance of the Uuid7 - all values are zeros.
    /// Please note this is not a valid UUID7 as it lacks the correct version bits.
    /// </summary>
    public static readonly Uuid7 Empty = new(new byte[16]);

    /// <summary>
    /// A read-only instance of the Uuid7 - all values are zeros.
    /// Please note this is not a valid UUID7 as it lacks the correct version bits.
    /// </summary>
    public static readonly Uuid7 MinValue = new(new byte[16]);

    /// <summary>
    /// A read-only instance of the Uuid7 - all values are FF.
    /// Please note this is not a valid UUID7 as it lacks the correct version bits.
    /// </summary>
    public static readonly Uuid7 MaxValue = new(new byte[] { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 });

    /// <summary>
    /// Returns a new UUID version 7.
    /// This method is thread-safe.
    /// For higher multi-threaded performance, consider using new Uuid7()
    /// instead, as it utilizes per-thread counters. While this doesn't
    /// guarantee strict sequencing, it provides no worse results than
    /// generating UUIDs on multiple computers.
    /// </summary>
    public static Uuid7 NewUuid7() {
        Span<byte> bytes = stackalloc byte[16];
        lock (NonThreadedSyncRoot) {
            FillBytes7(bytes, ref NonThreadedLastMillisecond, ref NonThreadedMillisecondCounter, ref NonThreadedMonotonicCounter);
        }
        return new Uuid7(bytes);
    }

    public static Uuid7 FromGuid(Guid value) => new Uuid7(value.ToByteArray(true));
    public Guid ToGuid() => new Guid(Bytes, true);
    public static Guid ToGuid(Uuid7 uuid7MemorySpan) => new Guid(uuid7MemorySpan.Bytes, true);

    public byte[] ToByteArray()
    {
        Span<byte> copy = stackalloc byte[16];
        Bytes.CopyTo(copy);
        return copy.ToArray();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    private static void FillBytes7(Span<byte> bytes, ref long lastMillisecond, ref long millisecondCounter, ref uint monotonicCounter)
    {
        var ticks = DateTime.UtcNow.Ticks; // DateTime is a smidgen faster than DateTimeOffset
        var millisecond = ticks / TicksPerMillisecond;
        var msCounter = millisecondCounter;

        var newStep = millisecond != lastMillisecond;
        if (newStep) {  // we need to switch millisecond (i.e. counter)
            lastMillisecond = millisecond;
            var ms = unchecked(millisecond - UnixEpochMilliseconds);
            if (msCounter < ms) {  // normal time progression
                msCounter = ms;
            } else { // time went backward, just increase counter
                unchecked { msCounter++; }
            }

            millisecondCounter = msCounter;
        }

        // Timestamp
        bytes[0] = (byte)(msCounter >> 40);
        bytes[1] = (byte)(msCounter >> 32);
        bytes[2] = (byte)(msCounter >> 24);
        bytes[3] = (byte)(msCounter >> 16);
        bytes[4] = (byte)(msCounter >> 8);
        bytes[5] = (byte)msCounter;

        // Randomness
        uint monoCounter;
        if (newStep) {
            GetRandomBytes(bytes, 6, 10);
            // to use as monotonic random for future calls; total of 26 bits but only 25 are used initially with upper 1 bit reserved for rollover guard
            monoCounter = (uint)(((bytes[6] & 0x07) << 22) | (bytes[7] << 14) | ((bytes[8] & 0x3F) << 8) | bytes[9]);
        } else {
            GetRandomBytes(bytes, 9, 7);
            // 4 bit random increment will reduce overall counter space by 3 bits on average (to 2^22 combinations)
            monoCounter = unchecked(monotonicCounter + ((uint)bytes[9] >> 4) + 1);
            bytes[7] = (byte)(monoCounter >> 14); // bits 14:21 of monotonic counter
            bytes[9] = (byte)(monoCounter); // bits 0:7 of monotonic counter
        }

        monotonicCounter = monoCounter;

        //Fixup
        bytes[6] = (byte)(0x70 | ((monoCounter >> 22) & 0x0F)); // set 4-bit version + bits 22:25 of monotonic counter
        bytes[8] = (byte)(0x80 | ((monoCounter >> 8) & 0x3F)); // set 2-bit variant + bits 8:13 of monotonic counter
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    private static void GetRandomBytes(Span<byte> bytes, int offset, int count)
    {
        var buffer = RandomBuffer.Value!.AsSpan();
        var bufferIndex = RandomBufferIndex.Value;

        if (unchecked(bufferIndex + count) > RandomBufferSize) {
            var leftover = unchecked(RandomBufferSize - bufferIndex);
            buffer.Slice(bufferIndex).CopyTo(bytes.Slice(offset, count)); // make sure to use all bytes

            offset = unchecked(offset + leftover);
            count = unchecked(count - leftover);

            Random.GetBytes(buffer);
            bufferIndex = 0;
        }

        buffer.Slice(bufferIndex, count).CopyTo(bytes.Slice(offset, count));
        RandomBufferIndex.Value = unchecked(bufferIndex + count);
    }

    #region IEquatable

    public override bool Equals(object? o)
    {
        if (o is Uuid7 uuid7) return Equals(uuid7);
        if (o is Guid guid) return Equals(guid);

        return false;
    }

    public override int GetHashCode()
    {
        return ((Bytes[3] ^ Bytes[7] ^ Bytes[11] ^ Bytes[15]) << 24)
            | ((Bytes[2] ^ Bytes[6] ^ Bytes[10] ^ Bytes[14]) << 16)
            | ((Bytes[1] ^ Bytes[5] ^ Bytes[9] ^ Bytes[13]) << 8)
            | (Bytes[0] ^ Bytes[4] ^ Bytes[8] ^ Bytes[12]);
    }

    public bool Equals(Uuid7 other)
    {
#if NET7_0_OR_GREATER
        if (Vector128.IsHardwareAccelerated)
        {
            var vector1 = Unsafe.ReadUnaligned<Vector128<byte>>(ref Bytes[0]);
            var vector2 = Unsafe.ReadUnaligned<Vector128<byte>>(ref other.ToByteArray()[0]);
            return vector1 == vector2;
        }
#endif
        return AreArraysEquals(Bytes, other.Bytes);
    }

    public bool Equals(Guid other)
    {
#if NET7_0_OR_GREATER
        if (Vector128.IsHardwareAccelerated)
        {
            var vector1 = Unsafe.ReadUnaligned<Vector128<byte>>(ref Bytes[0]);
            var vector2 = Unsafe.ReadUnaligned<Vector128<byte>>(ref other.ToByteArray(true)[0]);
            return vector1 == vector2;
        }
#endif
        return AreArraysEquals(Bytes, other.ToByteArray(true));
    }

    private static bool AreArraysEquals(ReadOnlySpan<byte> byteSpan1, ReadOnlySpan<byte> byteSpan2)
    {
        return byteSpan1.SequenceEqual(byteSpan2);
    }

    #endregion

    #region IComparable

    public int CompareTo(Uuid7 other)
    {
        return CompareArrays(Bytes, other.Bytes);
    }

    public int CompareTo(Guid other)
    {
        return CompareArrays(Bytes, other.ToByteArray(true));
    }

    public int CompareTo(object? obj)
    {
        if (obj == null) return 1;
        if (obj is Uuid7 uuid7) return CompareTo(uuid7);
        if (obj is Guid guid) return CompareTo(guid);

        throw new ArgumentException("Arg_MustBeGuidOrUuid");
    }

    private static int CompareArrays(ReadOnlySpan<byte> array1, ReadOnlySpan<byte> array2)
    {
        if (array1 == null || array1.Length != 16) return -1;
        if (array2 == null || array2.Length != 16) return +1;

        var comparer = Comparer<byte>.Default;
        for (var i = 0; i < array1.Length; i++)
        {
            switch (comparer.Compare(array1[i], array2[i]))
            {
                case < 0:
                    return -1;
                case > 0:
                    return +1;
            }
        }

        return 0;
    }

    #endregion

    #region Operators

    public static bool operator ==(Uuid7 left, Uuid7 right) => left.Equals(right);
    public static bool operator ==(Uuid7 left, Guid right) => left.Equals(right);
    public static bool operator ==(Guid left, Uuid7 right) => left.Equals(right);
    public static bool operator !=(Uuid7 left, Uuid7 right) => !(left == right);
    public static bool operator !=(Uuid7 left, Guid right) => !(left == right);
    public static bool operator !=(Guid left, Uuid7 right) => !(left == right);
    public static bool operator <(Uuid7 left, Uuid7 right) => left.CompareTo(right) < 0;
    public static bool operator <(Uuid7 left, Guid right) => left.CompareTo(right) < 0;
    public static bool operator <(Guid left, Uuid7 right) => left.CompareTo(right) < 0;
    public static bool operator <=(Uuid7 left, Uuid7 right) => left.CompareTo(right) is < 0 or 0;
    public static bool operator <=(Uuid7 left, Guid right) => left.CompareTo(right) is < 0 or 0;
    public static bool operator <=(Guid left, Uuid7 right) => left.CompareTo(right) is < 0 or 0;

    public static bool operator >=(Uuid7 left, Uuid7 right) => left.CompareTo(right) is > 0 or 0;
    public static bool operator >=(Uuid7 left, Guid right) => left.CompareTo(right) is > 0 or 0;

    public static bool operator >=(Guid left, Uuid7 right) => left.CompareTo(right) is > 0 or 0;
    public static bool operator >(Uuid7 left, Uuid7 right) => left.CompareTo(right) > 0;

    public static bool operator >(Uuid7 left, Guid right) => left.CompareTo(right) > 0;
    public static bool operator >(Guid left, Uuid7 right) => left.CompareTo(right) > 0;

    public static implicit operator Uuid7(Guid value) => FromGuid(value);
    public static implicit operator Guid(Uuid7 value) => ToGuid(value);

    #endregion Operators

    public override string ToString()
    {
        return ToString("D", provider: null);
    }

    /// <summary>
    /// Formats the value of the current instance using the specified format.
    /// The following format specifiers are supported:
    /// - D: Default - 32 digits separated by hyphens, e.g. 00000000-0000-0000-0000-000000000000
    /// </summary>
    /// <param name="format">The format to use.</param>
    /// <param name="provider">Ignored.</param>
    /// <exception cref="FormatException"></exception>
    public string ToString(string? format, IFormatProvider? provider)
    {
        if (string.IsNullOrEmpty(format)) format = "D";
        if (format.Length != 1) ThrowHelper.ThrowInvalidUuidFormatSpecification();
        return format[0] switch
        {
            'D' or 'd' => WriteAsDefaultString(),
            _ => ThrowHelper.ThrowInvalidUuidFormatSpecification()
        };
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private string WriteAsDefaultString()
    {
        byte offset = 0;
        Span<char> guidChars = stackalloc char[36];

        offset = HexsToChars(guidChars, offset, Bytes[0], Bytes[1]);
        offset = HexsToChars(guidChars, offset, Bytes[2], Bytes[3]);
        guidChars[offset++] = '-';
        offset = HexsToChars(guidChars, offset, Bytes[4], Bytes[5]);
        guidChars[offset++] = '-';
        offset = HexsToChars(guidChars, offset, Bytes[6], Bytes[7]);
        guidChars[offset++] = '-';
        offset = HexsToChars(guidChars, offset, Bytes[8], Bytes[9]);
        guidChars[offset++] = '-';
        offset = HexsToChars(guidChars, offset, Bytes[10], Bytes[11]);
        offset = HexsToChars(guidChars, offset, Bytes[12], Bytes[13]);
        HexsToChars(guidChars, offset, Bytes[14], Bytes[15]);

        return new string(guidChars);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static byte HexsToChars(Span<char> guidChars, byte offset, int byteOne, int byteTwo)
    {
        guidChars[offset++] = HexToChar(byteOne >> 4);
        guidChars[offset++] = HexToChar(byteOne);
        guidChars[offset++] = HexToChar(byteTwo >> 4);
        guidChars[offset++] = HexToChar(byteTwo);
        return offset;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static char HexToChar(int a)
    {
        a = a & 0xf;
        return (char)((a > 9) ? a - 10 + 0x61 : a + 0x30);
    }
}